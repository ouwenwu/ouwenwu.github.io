<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS</title>
    <url>/2023/03/23/CSS/</url>
    <content><![CDATA[<h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><ul>
<li>内联样式（元素的style属性中）</li>
<li>内部样式表（HTML的style元素中）</li>
<li>外部样式表（.css文件中，通过link元素导入）</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p><strong><em>text-decoration：</em></strong>none(无装饰线)、underline(下划线)、overline(上划线)、through(中划线/删除线)</p>
<p><strong><em>text-transform：</em></strong>capitaliza(每个单词首字母大写)、uppercase(每个单词字符变为大写)、lowercase(每个单词字符变小写)、none(没有影响)</p>
<p><strong><em>text-indent：</em></strong>（em/px）第一行内容的缩进——em是当前文字的大小，2em就是两个文字</p>
<p><strong><em>text-align：</em></strong>left(左对齐)、right(右对齐)、center(居中对齐)、justify(两端对齐)</p>
<ul>
<li>行内级元素的对齐方式</li>
<li>display:inline与width、height不能同时设置，行内级元素没有宽高（高度为line-height）</li>
</ul>
<p><strong><em>letter-spacing/word-spacing：</em></strong>分别设置字母、单词之间的间距（默认是0，可以为负数）</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong><em>font-size：</em></strong>字体大小</p>
<ul>
<li>具体数值加单位：100px、1em（em是父元素计算后的font-size）</li>
<li>百分比：基于父元素font-size计算</li>
</ul>
<p><strong><em>font-family：</em></strong>字体名称（一般设置一个，继承下去）</p>
<p><strong><em>font-wight：</em></strong>加粗 100|200|300|400|500|600|700|800|900   normal是400   bold是700</p>
<p><strong><em>font-style：</em></strong>斜体 normal(常规显示)、italic(用字体的斜体显示)、oblique(文本倾斜显示)</p>
<p><strong><em>font-variant：</em></strong>normal(常规显示)、small-caps(小写字母替换为缩小后的大写字母)</p>
<p><strong><em>line-height☆：</em></strong></p>
<ul>
<li>一行文字所占的高度</li>
<li>两行文字基线之间的间距</li>
<li><p>基线：与小写字母x最底部对齐的线</p>
</li>
<li><p>line-height实现文字垂直居中：line-height=height</p>
</li>
</ul>
<p><strong><em>display：</em></strong>block、inline（不可以随意设置宽高）、inline-block、flex</p>
<p>元素隐藏方法：</p>
<ul>
<li><strong>display:none</strong>；   元素不显示出来，不占据空间（和不存在一样）</li>
<li><strong>visivility:hidden;</strong>   元素不可见，但占据空间</li>
<li><strong>rgba设置a为0</strong>   设置alpha值，透明度，不会影响子元素</li>
<li><strong>opacity设置为0</strong>   会影响所有的子元素</li>
</ul>
<p>注：raba和opacity设置时，文字根据opacity显示</p>
<h2 id="常见选择器"><a href="#常见选择器" class="headerlink" title="常见选择器"></a>常见选择器</h2><ul>
<li>!important：10000</li>
<li>内联样式：1000</li>
<li>id选择器：100</li>
<li>类选择器、属性选择器、伪类：10</li>
<li>元素选择器、伪元素：1</li>
<li>通配符：0</li>
</ul>
<p>可以简单认为：选择器查询到的结果越多，权重越低</p>
<h3 id="css设置不生效："><a href="#css设置不生效：" class="headerlink" title="css设置不生效："></a>css设置不生效：</h3><ul>
<li>选择器优先级太低</li>
<li>选择器没选中对应的元素</li>
<li>css使用形式不对（例如行内级元素的宽高、被同类型css属性覆盖）</li>
</ul>
<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p><strong><em>宽高：</em></strong>width/height、min-height/max-height、max-width/min-height(移动端适配)</p>
<p><strong><em>padding：</em></strong>padding-top、padding-right、padding-bottom、padding-left</p>
<ul>
<li>10px 20px 30px 40px  分别对应：top、right、bottom、left</li>
<li>10px 20px 30px   缺少left，left使用right的值</li>
<li>10px 20px  缺少bottom、left分别使用top、right的值</li>
<li>10px  其余值都用这个值</li>
</ul>
<p><strong><em>border：</em></strong></p>
<ul>
<li>border-top-width、border-right-width、border-bottom-width、border-left-width</li>
<li>border-top-color、border-right-color、border-bottom-color、border-left-color</li>
<li>border-top-style、border-right-style、border-bottom-style、border-left-style</li>
<li>border-top、border-right、border-bottom、border-left</li>
<li>border-radius</li>
</ul>
<p>注：同样可以用border属性来进行缩写</p>
<p><strong><em>margin：</em></strong>与padding值的设置类似</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript运行原理</title>
    <url>/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong><em>浏览器内核（以webkit为例）：</em></strong>WebCore负责解析HTML、布局、渲染等；JavaScriptCore：解析、执行JavaScript代码</p>
<p><strong><em>ECMAScript3：</em></strong>用这个来学习JavaScript执行、作用域、作用域链、闭包等概念</p>
<p><strong><em>ECMAScript5：</em></strong>用这个来学习块级作用域、let、const等概念</p>
<p>两者概念描述不一样，整体思路一致</p>
<h1 id="V8引擎的执行原理"><a href="#V8引擎的执行原理" class="headerlink" title="V8引擎的执行原理"></a>V8引擎的执行原理</h1><p>V8是用C++编写的开源高性能JavaScript和WebAssembly引擎，可以用于Chrome和Node.js</p>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323184747752.png" alt="image-20230323184747752"></p>
<p><strong><em>Parse：</em></strong>将JavaScript代码转换为AST（抽象语法树）——函数在没调用的时候，不会被转换为抽象语法树</p>
<p><strong><em>Ignition：</em></strong>将AST转换为字节码</p>
<p><strong><em>TurboFan：</em></strong>将字节码编译为可以直接运行的机器码</p>
<ul>
<li>如果一个函数被多次调用，就会被标记为热点函数，就会被TurboFan转换为机器码，提高代码的执行性能</li>
<li>机器码也会被还原为ByteCode，如果后续执行函数的过程中，类型发生了变化，之前的机器码不能进行准确的运算，就会逆向转换为字节码</li>
</ul>
<h2 id="JavaScript执行过程"><a href="#JavaScript执行过程" class="headerlink" title="JavaScript执行过程"></a>JavaScript执行过程</h2><p><strong><em>执行上下文栈（ECS）：</em></strong>js引擎内部有一个执行上下文栈，是执行代码的调用栈</p>
<p><strong><em>全局执行上下文：</em></strong>全局代码块为了执行会生成一个全局执行上下文（GEC），并放入ECS中</p>
<p><strong><em>函数执行上下文：</em></strong>执行到一个函数值，会根据函数体创建一个函数执行上下文（FEC），并放入到ECS中</p>
<p><strong><em>AO对象：</em></strong>当进入一个函数执行上下文时，会创建一个AO对象，AO对象使用arguments作为初始化，初始值是传入的参数</p>
<p><strong><em>VO对象：</em></strong>每一个执行上下文都会关联一个VO（Variable Object）对象，变量和函数的声明会被添加到这个VO对象中</p>
<p><strong><em>注：</em></strong>全局上下文的VO对象就是GO、函数执行上下文的VO对象是AO</p>
<h3 id="初始化全局对象"><a href="#初始化全局对象" class="headerlink" title="初始化全局对象"></a>初始化全局对象</h3><p>js在执行代码前，会在堆内存中创建一个全局对象：Global Object（GO）</p>
<ul>
<li>该对象  所有的作用域（scope）都可以访问； </li>
<li>里面会包含Date、Array、String、Number、setTimeout、setInterval等等； </li>
<li>其中还有一个window属性指向自己；</li>
</ul>
<p>在parser转成AST的过程中，会将全局定义的变量、函数等放入GlobalObject中，但不会赋值（变量的作用域提升）</p>
<ul>
<li>JavaScript可以在变量声明前访问，但是值是undefined，浏览器会对函数进行特殊处理，使得其可以在定义前调用</li>
</ul>
<p>在代码执行过程中，对变量赋值或者执行其他的函数</p>
<p>全局代码执行前：</p>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323191418551.png" alt="image-20230323191418551"></p>
<p>全局代码执行后：</p>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323191040277.png" alt="image-20230323191040277"></p>
<p>函数执行前：</p>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323191504578.png" alt="image-20230323191504578"></p>
<p>函数执行后：</p>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323191448418.png" alt="image-20230323191448418"></p>
<h1 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h1><p><strong><em>作用域链：</em></strong>当进入到一个执行上下文时，执行上下文会关联一个作用域链，并根据代码类型，添加一系列的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">age</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>(<span class="number">18</span>)</span><br><span class="line"><span class="title function_">baz</span>()</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/23/JavaScript%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/image-20230323192141405.png" alt="image-20230323192141405"></p>
<ul>
<li>其作用域链中有两个，分别是foo的作用域、全局作用域</li>
</ul>
<p>注：作用域链是在函数声明是产生的，与调用时刻无关</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件化开发</title>
    <url>/2023/03/24/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="组件化开发（React二）"><a href="#组件化开发（React二）" class="headerlink" title="组件化开发（React二）"></a>组件化开发（React二）</h1><p><strong><em>组件化开发：</em></strong>如果把一个页面的所有处理逻辑放在一起，处理起来会很复杂，因此将一个页面拆分为不同的功能块</p>
<ul>
<li>一个完整的页面可以划分为很多个组件</li>
<li>每个组件都用于实现页面的一个功块</li>
<li>每一个组件又可以细分</li>
<li>组件本身又可以在很多地方复用</li>
</ul>
<p><img src="/2023/03/24/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20230324172119865.png" alt="image-20230324172119865"></p>
<p><strong><em>React组件：</em></strong></p>
<ul>
<li>类组件与函数组件</li>
<li>根据内部是否有状态需要维护：无状态组件、有状态组件（this.state，不考虑hooks的情况下函数组件是无状态组件，而类组件不定义this.state也可以看做无状态组件）</li>
<li>根据组件的不同职责：展示型组件、容器型组件</li>
</ul>
<p><strong><em>组件之间有重叠，但都是为了数据逻辑和UI展示的分离</em></strong></p>
<ul>
<li>函数组件、无状态组件、展示型组件主要关注UI的展示</li>
<li>类组件、有状态组件、容器型组件主要关注数据逻辑</li>
</ul>
<h1 id="类组件与函数组件"><a href="#类组件与函数组件" class="headerlink" title="类组件与函数组件"></a>类组件与函数组件</h1><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><p><strong><em>定义要求：</em></strong>首字母大写、继承自React.Component、实现render函数</p>
<ul>
<li>constructor可选，在其中初始化数据</li>
<li>this.state中维护组件内部的数据</li>
<li>render是类组件<strong>唯一必须实现的方法</strong></li>
</ul>
<h2 id="函数组件（没有hooks的函数组件）"><a href="#函数组件（没有hooks的函数组件）" class="headerlink" title="函数组件（没有hooks的函数组件）"></a>函数组件（没有hooks的函数组件）</h2><ul>
<li>没有生命周期、会被挂载、没有生命周期函数</li>
<li>this关键字不能指向组件实例，因为没有组件实例</li>
<li>没有内部状态state</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><strong><em>生命周期：</em></strong>从创建到销毁的整个过程，了解生命周期在最合适的地方完成想要的功能</p>
<h2 id="React的生命周期、生命周期函数"><a href="#React的生命周期、生命周期函数" class="headerlink" title="React的生命周期、生命周期函数"></a>React的生命周期、生命周期函数</h2><ul>
<li>装载阶段：组件第一次在DOM树种被渲染的过程——装载完成：componentDidMount</li>
<li>更新阶段：组件状态发生变化，重新更新渲染的过程——更新完成：componentDidUpdate</li>
<li>卸载阶段：组件从DOM树种被移除的过程——即将移除：componentWillUnmount</li>
</ul>
<p><img src="/2023/03/24/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20230324173626696.png" alt="image-20230324173626696"></p>
<h3 id="各函数任务及时刻"><a href="#各函数任务及时刻" class="headerlink" title="各函数任务及时刻"></a>各函数任务及时刻</h3><p><strong><em>constructor：</em></strong></p>
<ul>
<li>不初始化state或不进行方法绑定，则可以不实现构造函数</li>
<li>作用一：给this.state赋值对象来初始化state</li>
<li>作用二：为事件绑定this——调用super()</li>
</ul>
<p><strong><em>componentDidMount：</em></strong></p>
<ul>
<li>组件挂载到DOM Tree后立马调用</li>
<li>作用一：进行依赖于DOM的操作</li>
<li>作用二：发送网络请求的最好位置</li>
<li>作用三：添加订阅</li>
</ul>
<p><strong><em>componentDidUpdate：</em></strong></p>
<ul>
<li>组件更新后立即调用，首次渲染不会执行这个方法</li>
<li>作用一：组件更新后，此处进行DOM相关操作</li>
<li>作用二：当更新前后props发送了变化，此处发送网络请求</li>
</ul>
<p><strong><em>componentWIllUnmount：</em></strong></p>
<ul>
<li>组件卸载及销毁之前直接调用</li>
<li>作用一：进行必要的清理操作</li>
<li>作用二：清除timer，取消网络请求或取消上面创建的订阅</li>
</ul>
<h3 id="不常用生命周期函数"><a href="#不常用生命周期函数" class="headerlink" title="不常用生命周期函数"></a>不常用生命周期函数</h3><ul>
<li>getDerivedStateFromProps：state 的值在任何 时候都依赖于 props时使用；该方法返回一个对象 来更新state</li>
<li>getSnapshotBeforeUpdate：在React更新DOM 之前回调的一个函数，可以获取DOM更新前的一 些信息（比如说滚动位置）</li>
<li>shouldComponentUpdate：该生命周期函数很 常用，但是我们等待讲性能优化时再来详细讲解</li>
</ul>
<p><img src="/2023/03/24/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20230324174415395.png" alt="image-20230324174415395"></p>
<h1 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h1><h2 id="父组件传值到子组件"><a href="#父组件传值到子组件" class="headerlink" title="父组件传值到子组件"></a>父组件传值到子组件</h2><ul>
<li>父组件通过 属性=值 的形式来传递给子组件数据</li>
<li>子组件通过props参数获取父组件传过来的值</li>
</ul>
<p><strong><em>默认值设置：</em></strong>ChildComponent.defaultProps</p>
<p><strong><em>参数类型设置：</em></strong>ChildComponent.propTypes    isRequired代表是否必须</p>
<p><strong><em>父组件代码：</em></strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&quot;./component/ChildComponent&quot;</span>;</span><br><span class="line"><span class="comment">//编写组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;I am your father!&quot;</span>,</span><br><span class="line">            <span class="attr">info</span>:<span class="string">&quot;You are my child!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;message,info&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">info</span> = <span class="string">&#123;info&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码：</em></strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PropTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ChildComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ([</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>&#123;this.props.info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>&#123;this.props.info2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildComponent</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">info</span>:<span class="string">&quot;Tell me who are you!&quot;</span>,</span><br><span class="line">    <span class="attr">info2</span>:<span class="string">&quot;You are my Dad!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComponent</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/24/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20230324180859034.png" alt="image-20230324180859034"></p>
<h2 id="子组件传值到父组件"><a href="#子组件传值到父组件" class="headerlink" title="子组件传值到父组件"></a>子组件传值到父组件</h2><ul>
<li>通过props给子组件传递一个回调函数，在子组件中调用这个函数</li>
</ul>
<p><strong><em>父组件代码：</em></strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&quot;./component/ChildComponent&quot;</span>;</span><br><span class="line"><span class="comment">//编写组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;I am your father!&quot;</span>,</span><br><span class="line">            <span class="attr">info</span>:<span class="string">&quot;You are my child!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dataFromChild = <span class="keyword">function</span>(<span class="params">info</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">message</span>:info</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;message,info&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">info</span> = <span class="string">&#123;info&#125;</span> <span class="attr">dataFromChild</span> = <span class="string">&#123;(message)</span>=&gt;</span> this.dataFromChild(message)&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码：</em></strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PropTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ChildComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    sendDataToFather = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">dataFromChild</span>(<span class="number">555</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ([</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onClick</span> = <span class="string">&#123;()</span>=&gt;</span>&#123;this.sendDataToFather()&#125;&#125;&gt;&#123;this.props.info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>&#123;this.props.info2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ChildComponent</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">info</span>:<span class="string">&quot;Tell me who are you!&quot;</span>,</span><br><span class="line">    <span class="attr">info2</span>:<span class="string">&quot;You are my Dad!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComponent</span></span><br></pre></td></tr></table></figure>
<p>注：各个地方函数的使用要注意，是否需要this，一般传递过去的函数都是箭头函数，调用的函数一般为function</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ChildComponent</span> info = &#123;info&#125; dataFromChild = &#123;<span class="function">(<span class="params">message</span>)=&gt;</span> <span class="variable language_">this</span>.<span class="title function_">dataFromChild</span>(message)&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">info</span> = <span class="string">&#123;info&#125;</span> <span class="attr">dataFromChild</span> = <span class="string">&#123;this.dataFromChild&#125;/</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果直接传递，那么函数的调用由React确定就不知道this是啥</p>
<p>传递过去箭头函数，那么我们不关心什么时候调用这个箭头函数，而箭头函数包含的是隐式绑定的this，所以调用的函数需要function，要不然找不到this</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p><a href="www.baidu.com">asasa</a></p>
]]></content>
  </entry>
  <entry>
    <title>jquery</title>
    <url>/2023/03/22/jquery/</url>
    <content><![CDATA[<h1 id="jQuery是一个快速、小型且功能丰富的JavaScript"><a href="#jQuery是一个快速、小型且功能丰富的JavaScript" class="headerlink" title="jQuery是一个快速、小型且功能丰富的JavaScript"></a>jQuery是一个快速、小型且功能丰富的JavaScript</h1><p>优点：丰富的功能（DOM操作、过滤器、时间、动画、Ajax等）、编写更少可读的代码提高开发人员的工作效率、跨浏览器支持（IE9+）</p>
<p>缺点：jQuery代码库一直在增长（jQuery1.5超过200KB）、不支持组件化开发、jQuery更适合组件化开发，当涉及到复杂的项目时，能力有限</p>
<h2 id="jQuery使用"><a href="#jQuery使用" class="headerlink" title="jQuery使用"></a>jQuery使用</h2><h3 id="jQuery监听文档加载"><a href="#jQuery监听文档加载" class="headerlink" title="jQuery监听文档加载"></a>jQuery监听文档加载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$( <span class="variable language_">document</span> ).<span class="title function_">ready</span>( handler )  ：  <span class="comment">//deprecated </span></span><br><span class="line">$( <span class="string">&quot;document&quot;</span> ).<span class="title function_">ready</span>( handler ) ：  <span class="comment">//deprecated </span></span><br><span class="line">$().<span class="title function_">ready</span>( handler ) ：<span class="comment">//deprecated </span></span><br><span class="line">$( handler ) ：<span class="comment">//推荐用这种写法，其它可以使用但是不推荐</span></span><br></pre></td></tr></table></figure>
<h3 id="jQuery与其他库变量名冲突（jQuery别名-的冲突）"><a href="#jQuery与其他库变量名冲突（jQuery别名-的冲突）" class="headerlink" title="jQuery与其他库变量名冲突（jQuery别名$的冲突）"></a>jQuery与其他库变量名冲突（jQuery别名$的冲突）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.<span class="title function_">noConflict</span>()</span><br></pre></td></tr></table></figure>
<h3 id="jQuery对象（类数组对象——可通过索引访问）"><a href="#jQuery对象（类数组对象——可通过索引访问）" class="headerlink" title="jQuery对象（类数组对象——可通过索引访问）"></a>jQuery对象（类数组对象——可通过索引访问）</h3><ul>
<li>如果传入假值：返回一个空的集合。 </li>
<li>如果传入选择器：返回在在documnet中所匹配到元素的集合。 </li>
<li>如果传入元素：返回包含该元素的集合。 </li>
<li>如果传入HTML字符串，返回包含新创建元素的集合。 </li>
<li>如果传入回调函数：返回的是包含document元素集合, 并且当文档加载完成会回调该函数。 </li>
<li>因为函数也是对象，所以该函数还包含了很多已封装好的方法。如：jQuery.noConflict、jQuery.ready等</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;oww&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = $()  <span class="comment">// 创建空对象</span></span><br><span class="line"><span class="keyword">const</span> obj2 = $(obj) <span class="comment">// 通过j对象创建jQuery对象</span></span><br><span class="line"><span class="keyword">const</span> obj3 = $(<span class="string">&#x27;li&#x27;</span>) <span class="comment">// 通过选择器创建jQuery对象</span></span><br></pre></td></tr></table></figure>
<p>jQuery对象与Element对象的区别：jQuery会包含所选择到的对象，可以通过$(element)和obj3[index]之间相互转换，转换后具有不同的函数</p>
<h4 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h4><p>常规选择器：通用选择器（*）、属性/后代/基本（id、class、元素）/兄弟/交集/伪元素（伪类不行）/可见选择器（:visible,:hidden）、jQuery扩展选择器（:eq(),:odd,:even:first:last）—eq是用索引、odd奇数、even偶数</p>
<h3 id="jQuery过滤器"><a href="#jQuery过滤器" class="headerlink" title="jQuery过滤器"></a>jQuery过滤器</h3><ul>
<li>eq(index):  从匹配元素的集合中，取索引处的元素， eq全称(equal 等于)，返回jQuery对象。 </li>
<li>first() : 从匹配元素的集合中，取第一个元素，返回jQuery对象。 </li>
<li>last(): 从匹配元素的集合中，取最后一个元素，返回jQuery对象。 </li>
<li>not(selector):  从匹配元素的集合中，删除匹配的元素，返回jQuery对象。 </li>
<li>filter(selector): 从匹配元素的集合中，过滤出匹配的元素，返回jQuery对象。 </li>
<li>.find(selector): 从匹配元素集合中，找到匹配的后代元素，返回jQuery对象。 </li>
<li>is(selector|element| . ): 根据选择器、元素等检查当前匹配到元素的集合。集合中至少有一个与给定参数匹配则返回true。   8.odd() :将匹配到元素的集合减少为集合中的奇数，从零开始编号，返回jQuery对象。 </li>
<li>even()：将匹配到元素的集合减少到集合中的偶数，从零开始编号，返回jQuery对象。 </li>
<li>支持链式调用</li>
<li>on添加监听</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">$li.<span class="title function_">click</span>(<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>, event)</span><br><span class="line">&#125;)</span><br><span class="line">$li.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>, event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="../../public/images/jquery-click监听.png" alt></p>
<h3 id="jQuery函数"><a href="#jQuery函数" class="headerlink" title="jQuery函数"></a>jQuery函数</h3><h4 id="jQuery对文本的操作"><a href="#jQuery对文本的操作" class="headerlink" title="jQuery对文本的操作"></a>jQuery对文本的操作</h4><p>.text()、.text(text)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active list div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">pp</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>9<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> $li.<span class="title function_">text</span>()) <span class="comment">// string 会把其本身和子元素的text拼接为1个string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($li.<span class="title function_">text</span>()) <span class="comment">// 123456789</span></span><br><span class="line">$li.<span class="title function_">text</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// 更改所有选择元素的text</span></span><br></pre></td></tr></table></figure>
<p>.html、.html(htmlString)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($li.<span class="title function_">html</span>())  <span class="comment">// &lt;p&gt;1&lt;/p&gt; 获取选中第一个元素的html</span></span><br><span class="line">$li.<span class="title function_">html</span>(<span class="string">&quot;&lt;span&gt;10&lt;span&gt;&quot;</span>) <span class="comment">//给所有选中元素设置innerHtml</span></span><br></pre></td></tr></table></figure>
<p>.val()、.val(value)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($li.<span class="title function_">odd</span>().<span class="title function_">val</span>()) <span class="comment">// 2 获取选中第一个元素的value</span></span><br><span class="line">$li.<span class="title function_">val</span>(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h4 id="jQuery对css的操作"><a href="#jQuery对css的操作" class="headerlink" title="jQuery对css的操作"></a>jQuery对css的操作</h4><p>.width()、.height()、.css(prppertyName) 获取选中第一个元素的指定样式属性值</p>
<p>.css(propertyName,value)、.css({propertyName1:value1,propertyName2，value2})  为每一个匹配到的元素设置属性</p>
<h4 id="jQuery对class的操作"><a href="#jQuery对class的操作" class="headerlink" title="jQuery对class的操作"></a>jQuery对class的操作</h4><p>.addClass(className)、.addClass(classNames)、.addClass(funcntion)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $li = $(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">$li.<span class="title function_">addClass</span>(<span class="keyword">function</span>(<span class="params">index</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;active1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;active2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;) <span class="comment">// 通过this手动给选中的元素添加类</span></span><br><span class="line">$li.<span class="title function_">addClass</span>(<span class="function">(<span class="params">index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;active1&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;active2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;) <span class="comment">// 通过返回类名，jQuery给元素添加类</span></span><br></pre></td></tr></table></figure>
<p>.hasClass(className) 判断匹配到的元素是否分配了该类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $div = $(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($div.<span class="title function_">hasClass</span>(<span class="string">&quot;active&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($div.<span class="title function_">hasClass</span>(<span class="string">&quot;active list&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($div.<span class="title function_">hasClass</span>(<span class="string">&quot;active div&quot;</span>)) <span class="comment">// false 该方法是判断所选中元素是否包含要查询的类的字符串</span></span><br></pre></td></tr></table></figure>
<p>.removeClass()、.removeClass(className)、.removeClass(classNames)、.removeClass(function)  删除指定的类</p>
<p>.toggleClass()、.toggleClass(className[,state])、.toggleClass(classNames[,state]) 删除或添加指定的类</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2023/03/21/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h1 id="this的绑定"><a href="#this的绑定" class="headerlink" title="this的绑定"></a>this的绑定</h1><h2 id="一-整理this的绑定规则"><a href="#一-整理this的绑定规则" class="headerlink" title="一. 整理this的绑定规则"></a>一. 整理this的绑定规则</h2><ul>
<li><p>默认绑定：独立函数调用，函数没有被绑定到某个对象上进行调用</p>
</li>
<li><p>隐式绑定：通过某个对象发起的函数调用，在调用对象内部有一个对函数的引用。</p>
</li>
<li><p>显式绑定：明确this指向的对象，第一个参数相同并要求传入一个对象。</p>
<ul>
<li>apply/call</li>
<li>bind</li>
</ul>
</li>
<li><p>new绑定：</p>
<ul>
<li>创建一个全新对象</li>
<li>新对象被执行prototype链接</li>
<li>新对象绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，表达式会返回这个对象</li>
</ul>
</li>
</ul>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定this一般情况下是window</p>
<p>在严格模式下this为undefined</p>
<p>es6后的class中函数默认为严格模式，即this为undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>()</span><br><span class="line"><span class="keyword">const</span> bar = test.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>babel会将js设置为严格模式——在React框架下，隐式绑定都为undefined</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="二-说出apply、call、bind函数的用法和区别"><a href="#二-说出apply、call、bind函数的用法和区别" class="headerlink" title="二. 说出apply、call、bind函数的用法和区别"></a>二. 说出apply、call、bind函数的用法和区别</h2><p>​      用法：</p>
<ul>
<li><p>​    apply</p>
<p>​     第一个参数: 绑定this</p>
<p>​    第二个参数: 传入额外的实参, 以数组的形式</p>
</li>
<li><p>​    call</p>
<p>​    第一个参数: 绑定this</p>
<p>​    参数列表: 后续的参数以多参数的形式传递, 会作为实参</p>
</li>
<li><p>​    bind(不希望obj对象身上有函数)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj)</span><br><span class="line">​    <span class="title function_">bar</span>() <span class="comment">// this -&gt; obj</span></span><br></pre></td></tr></table></figure>
<p>区别：</p>
</li>
<li><p>call、apply和bind都可以改变函数的this指向</p>
</li>
<li><p>call、apply和bind第一个参数的是this要指向的对象</p>
</li>
<li><p>call、apply和bind都可以后续为函数传参，apply是将参数并成一个数组，call和bind是将参数依次列出</p>
</li>
<li><p>call、apply都是直接调用，bind生成的this指向改变函数需要手动调用。</p>
</li>
</ul>
<p>​        绑定优先级：</p>
<p>​        默认绑定的优先级最低、显示绑定的优先级高于隐式绑定、new绑定的优先级高于隐式绑定、new绑定优先级高于bind</p>
<p>​        new绑定和call、apply不可以一起使用</p>
<p>​        注：</p>
<p>​        显示绑定传入null或undefined，显示绑定会忽略使用默认规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>)</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 都是windows</span></span><br></pre></td></tr></table></figure>
<h2 id="三-说出箭头函数的各种用法和简写"><a href="#三-说出箭头函数的各种用法和简写" class="headerlink" title="三. 说出箭头函数的各种用法和简写"></a>三. 说出箭头函数的各种用法和简写</h2><ul>
<li><p>基本写法</p>
<ul>
<li><p>()：函数的参数</p>
</li>
<li><p>{}:函数的执行体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo3 = (name, age) =&gt; &#123;</span><br><span class="line">    console.log(&quot;箭头函数的函数体&quot;)</span><br><span class="line">    console.log(name, age)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>优化写法</p>
<ul>
<li><p>只有一个参数时, 可以省略()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">names.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>只有一行代码时, 可以省略{}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">names.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>只要一行代码时, 表达式的返回值会作为箭头函数默认返回值, 所以可以省略return</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果箭头函数默认返回的是对象, 在省略{}的时候, 对象必须使用()包裹 () =&gt; ({name: “why”})</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; &#123;&#125; <span class="comment">// 注意: 这里是&#123;&#125;执行体</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrFn</span>())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四-完成this的面试题解析"><a href="#四-完成this的面试题解析" class="headerlink" title="四. 完成this的面试题解析"></a>四. 完成this的面试题解析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// window</span></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// person</span></span><br><span class="line">  (person.<span class="property">sayName</span>)(); <span class="comment">// person</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)(); <span class="comment">// window </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo1(); // person1</span></span><br><span class="line"><span class="comment">// person1.foo1.call(person2); // person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo2(); // window</span></span><br><span class="line"><span class="comment">// person1.foo2.call(person2); // window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()(); // window</span></span><br><span class="line"><span class="comment">// person1.foo3.call(person2)(); // window</span></span><br><span class="line"><span class="comment">// person1.foo3().call(person2); // person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4()(); // person1</span></span><br><span class="line"><span class="comment">// person1.foo4.call(person2)(); // person2</span></span><br><span class="line"><span class="comment">// person1.foo4().call(person2); // person1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo1() // person1</span></span><br><span class="line"><span class="comment">// person1.foo1.call(person2) // person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo2() // person1</span></span><br><span class="line"><span class="comment">// person1.foo2.call(person2) // person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo3()() // window</span></span><br><span class="line"><span class="comment">// person1.foo3.call(person2)() // window</span></span><br><span class="line"><span class="comment">// person1.foo3().call(person2) // person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.foo4()() // person1</span></span><br><span class="line"><span class="comment">// person1.foo4.call(person2)() // person2</span></span><br><span class="line"><span class="comment">// person1.foo4().call(person2) // person1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.obj.foo1()() // window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1.call(person2)() // window</span></span><br><span class="line"><span class="comment">// person1.obj.foo1().call(person2) // person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.obj.foo2()() // obj</span></span><br><span class="line"><span class="comment">// person1.obj.foo2.call(person2)() // person2</span></span><br><span class="line"><span class="comment">// person1.obj.foo2().call(person2) // obj</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个React项目及React基础</title>
    <url>/2023/03/24/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%E5%8F%8AReact%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong><em>官网：</em></strong><a href="https://zh-hans.reactjs.org/">https://zh-hans.reactjs.org/</a></p>
<h1 id="React简单项目创建（React一）"><a href="#React简单项目创建（React一）" class="headerlink" title="React简单项目创建（React一）"></a>React简单项目创建（React一）</h1><h2 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h2><ul>
<li>声明书编程：只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染UI界面</li>
<li>组件化开发：将复杂的界面拆分为一个个小的组件</li>
<li>多平台适配：React(Web)、ReactNative(移动端平台)、ReactVR(虚拟现实Web应用程序)——虚拟DOM也对跨平台有很大用处</li>
</ul>
<h2 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a>React开发依赖</h2><ul>
<li><strong><em>react：</em></strong>react所必须的核心代码</li>
<li><strong><em>react-dom：</em></strong>react渲染在不同平台上所需要的核心代码——虚拟DOM→真实DOM（浏览器）/原生控件（移动端）</li>
<li><strong><em>babel：</em></strong>将jsx转换为React代码的工具，如果直接用React.createElement来写React对象，可以不用babel，同时可以将ES6转换为ES5语法</li>
</ul>
<p>react CDN引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="React第一个Hello-World"><a href="#React第一个Hello-World" class="headerlink" title="React第一个Hello World"></a>React第一个Hello World</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- root作为根节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">const</span> message = <span class="string">&quot;hello World&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">    root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>注：</em></strong></p>
<ul>
<li>script一定要设置 type=”text/babel” 否则不会被babel解析，jsx语法就不能识别</li>
<li>ReactDom.createRoot()是创建一个React根，不一定是整个html的根</li>
<li>render函数，参数是要渲染的组件</li>
<li>{}语法可以引入JavaScript语法</li>
</ul>
<h1 id="React组件化开发"><a href="#React组件化开发" class="headerlink" title="React组件化开发"></a>React组件化开发</h1><p><strong><em>组件化开发：</em></strong>root.render参数是一个HTML元素或一个组件，那么可以将复杂的业务逻辑封装到一个组件中，然后传入到ReactDom.render中</p>
<p><strong><em>React组件：</em></strong></p>
<ul>
<li>类组件与函数组件</li>
<li>根据内部是否有状态需要维护：无状态组件、有状态组件（this.state，不考虑hooks的情况下函数组件是无状态组件，而类组件不定义this.state也可以看做无状态组件）</li>
<li>根据组件的不同职责：展示型组件、容器型组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">movies</span>:[<span class="string">&quot;盗梦空间&quot;</span>,<span class="string">&quot;星际穿越&quot;</span>,<span class="string">&quot;大话西游&quot;</span>,<span class="string">&quot;流浪地球&quot;</span>],</span><br><span class="line">            <span class="attr">currentIndex</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">clickLi</span>(<span class="params">event,index</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">currentIndex</span>:index&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            	&#123;this.state.movies.map((item,index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">           			 return( </span></span><br><span class="line"><span class="language-xml">                			<span class="tag">&lt;<span class="name">li</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                				<span class="attr">key</span>=<span class="string">&#123;item&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        						<span class="attr">onClick</span>=<span class="string">&#123;(event)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            						this.clickLi(event,index)</span></span><br><span class="line"><span class="language-xml">        						&#125;&#125; </span></span><br><span class="line"><span class="language-xml">    							className = &#123;index===this.state.currentIndex?&quot;active&quot;:&quot;&quot;&#125;&gt;&#123;item&#125;</span></span><br><span class="line"><span class="language-xml">    						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    					)</span></span><br><span class="line"><span class="language-xml">				&#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h2><ul>
<li><strong><em>参与界面更新的数据：</em></strong>当数据改变时，需要更新组件渲染的数据（调用this.setState更新数据会自动检测改变的变量，并重新执行render函数更新页面）——参与数据流，放入当前对象的state对象中</li>
<li><strong><em>不参与页面更新的数据：</em></strong>数据改变时，不需要更新页面的数据</li>
</ul>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p><strong><em>this指向问题：</em></strong></p>
<ul>
<li>babel默认严格模式，那么默认调用的函数的this为undefined</li>
<li>一般的button点击，this指向button本身，但是这里调用的button是一个React的Element对象，并不是页面中的button，是React内部调用响应函数，因此不知道如何绑定正确的this</li>
</ul>
<p><strong><em>绑定this方法：</em></strong></p>
<ul>
<li><p>bind方法：调用bind方法生成一个带特定this的函数赋值给onClick</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.changeText.bind(this)&#125;&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数方法：如上面代码，给onClick赋值一个箭头函数，在箭头函数中调用隐式绑定想要运行的函数，箭头函数由于没有this，会向上寻找到this即class对象</p>
</li>
</ul>
<p><strong><em>事件参数传递：</em></strong>点击函数会传入一个event，可以将event与其他的参数放在箭头函数里面调用函数时传给最后的响应函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li onClick=&#123;event=&gt;this.clickLi(event,&quot;oww&quot;,&quot;22&quot;)&#125;&gt;按钮&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<h2 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h2><p>往往会从数据数组中得到要展示的Element列表，就可以使用map映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;this.state.movies.map((item,index)=&gt;&#123;</span><br><span class="line">        return( </span><br><span class="line">            &lt;li </span><br><span class="line">                key=&#123;item&#125; </span><br><span class="line">                onClick=&#123;(event)=&gt;&#123;</span><br><span class="line">                    this.clickLi(event,index)</span><br><span class="line">                &#125;&#125; </span><br><span class="line">                className = &#123;index===this.state.currentIndex?&quot;active&quot;:&quot;&quot;&#125;&gt;&#123;item&#125;</span><br><span class="line">			&lt;/li&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;)&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;div&gt;Hello World&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>类似于上诉代码的形式就是一个JSX代码</p>
<p><strong><em>React选择JSX的理由：</em></strong></p>
<ul>
<li><p>React认为渲染逻辑本质上与其他UI逻辑存在耦合（UI需要绑定事件、UI需要展示数据状态、状态改变时，又会改变UI）</p>
</li>
<li><p>因为渲染逻辑与UI逻辑的耦合，React没有将标记分离到不同的文件中，而是组合在一起形成组件</p>
</li>
</ul>
<p>注：JSX只能有一个根元素，也就是上面不能存在两个兄弟DIV，实在需要可以用数组[]包围，JSX中的单标签必须以/&gt;结尾</p>
<h3 id="JSX中的变量"><a href="#JSX中的变量" class="headerlink" title="JSX中的变量"></a>JSX中的变量</h3><ul>
<li>Number、String、Array可以直接显示</li>
<li>null、undefined、Boolean内容为空，如确实要显示，转换为字符串后使用</li>
<li>嵌入表达式使用（运算表达式、三元运算符、执行函数——是一个函数的执行得到返回值）</li>
<li>Object对象不能作为子元素</li>
</ul>
<h3 id="JSX绑定属性"><a href="#JSX绑定属性" class="headerlink" title="JSX绑定属性"></a>JSX绑定属性</h3><ul>
<li><strong><em>title属性/img的src属性/a元素href属性：</em></strong>直接使用title/src/href=””/{}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;h2 title=&quot;h2&quot;&gt;哈哈哈&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>class属性：</em></strong>小驼峰法className设置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;h2 className=&#123;&#x27;abc cba $&#123;isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#x27;&#125;&gt;哈哈哈&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>内联style属性：</em></strong>style=””/{}设置——外层{}是JSX语法，里层{}是包裹对象，font-size要用小驼峰法fontSize</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element= &lt;h2 style=&#123;&#123;color:&quot;red&quot;, fontSize:&quot;30px&quot;&#125;&#125;&gt;哈哈哈&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JSX本质"><a href="#JSX本质" class="headerlink" title="JSX本质"></a>JSX本质</h3><p>JSX实际上是React.createElement的语法糖，下面两种方法等效，label会将JSX转换为React对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = React.createElement(&#x27;div&#x27;,&#123;class:&quot;active&quot;,style=&#123;color:&quot;red&quot;&#125;&#125;,children)</span><br><span class="line">const element = &lt;div className = &quot;active&quot; style=&#123;&#123;color:&quot;red&quot;&#125;&#125;&gt;children1,children2&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><ul>
<li><p>通过React.createElement最终可以创建出一个ReactElement对象，其与其子元素构成一个对象树，这个树就是<strong>虚拟DOM</strong></p>
</li>
<li><p>React从JSX到真实DOM的流程：</p>
<p><img src="/2023/03/24/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%E5%8F%8AReact%E5%9F%BA%E7%A1%80/image-20230324165543425.png" alt="image-20230324165543425"></p>
</li>
</ul>
<h2 id="虚拟DOM帮助实现声明式编程"><a href="#虚拟DOM帮助实现声明式编程" class="headerlink" title="虚拟DOM帮助实现声明式编程"></a>虚拟DOM帮助实现声明式编程</h2><p><strong><em>虚拟DOM：</em></strong>虚拟DOM是一种编程理念</p>
<ul>
<li>UI以一种虚拟化的方式保存在内存中，是一个较为简单的JavaScript对象</li>
<li>通过ReactDom.render函数让虚拟DOM与真实DOM同步起来，这一个步骤叫做协调</li>
<li>更新状态后整体刷新，而不是原生的局部刷新</li>
</ul>
<p><strong><em>Diff算法：</em></strong>如果简单的整体刷新会导致项目运行效率较低</p>
<ul>
<li>Diff算法对于没有改变的DOM节点，保持原样不动，仅仅创建并替换变更过的DOM节点，实现DOM节点复用</li>
<li>因此需要实现DOM节点的版本控制，如果对原生的DOM节点进行版本控制，会有大量的DOM查询操作，所以React将DOM的diff操作转移到轻量js对象上，可以避免大量的DOM操作，这个轻量的js对象就是虚拟DOM</li>
</ul>
<p><strong><em>实现过程：</em></strong></p>
<ul>
<li>维护一个使用JS对象表示的虚拟DOM，与真实DOM一一对应</li>
<li>对前后的虚拟DOM做diff操作，找到变化的虚拟DOM</li>
<li>将变化的DOM应用于真实DOM（<strong>不是不操作DOM，而是对DOM的操作次数降到最低</strong>）</li>
</ul>
<h3 id="React的声明式编程"><a href="#React的声明式编程" class="headerlink" title="React的声明式编程"></a>React的声明式编程</h3><ul>
<li>通过虚拟DOM表示希望UI是什么状态</li>
<li>React确保DOM和这些状态匹配</li>
<li>不需要直接进行DOM操作，而去改变虚拟DOM，从手动更改DOM、属性操作、事件处理中解放出来（传统的DOM API太多，操作复杂，容易出现Bug，代码不易维护），用户只需要关心状态和最终的UI样式</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器优化</title>
    <url>/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="回流reflow和重绘repaint"><a href="#回流reflow和重绘repaint" class="headerlink" title="回流reflow和重绘repaint"></a>回流reflow和重绘repaint</h1><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p>第一次确定节点的大小和位置，称为布局</p>
<p>后续对节点的大小、位置修改并重新计算称为回流</p>
<h3 id="引起回流的情况"><a href="#引起回流的情况" class="headerlink" title="引起回流的情况"></a>引起回流的情况</h3><ul>
<li>DOM结构发生变化（添加或删除节点）</li>
<li>改变布局（修改width、height、padding、font-size等）</li>
<li>修改窗口大小</li>
<li>调用getComputedStyle方法获取尺寸、位置星系、</li>
</ul>
<h3 id="避免回流的方法"><a href="#避免回流的方法" class="headerlink" title="避免回流的方法"></a>避免回流的方法</h3><p>修改样式时尽量一次性修改，比如通过cssText修改，或者通过添加class修改，而不是对css的各种属性分次修改</p>
<p>避免频繁的操作DOM，可以使用虚拟DOM，或在父元素中要操作的DOM完成，再一次性更新到DOM中</p>
<h4 id="composite合成"><a href="#composite合成" class="headerlink" title="composite合成"></a>composite合成</h4><p>绘制的过程中，浏览器会将布局后的元素绘制到多个图层中</p>
<p>默认情况下，标准流中的内容被绘制在同一个图层，对于某些特殊的属性，会创建一个新的图层，这些图层可以利用GPU加速绘制</p>
<p>可以形成新的合成层的属性：3D transforms、video、canvas、iframe、opacity、position：fixed、will-change、animation或transition设置了opacity、transform</p>
<p>分层确实可以提高性能，但以内存管理为代价，因此不能作为Web性能优化的一部分过渡使用</p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>第一次渲染内容称为绘制</p>
<p>后续重新渲染称为重绘</p>
<h3 id="引起重绘的情况"><a href="#引起重绘的情况" class="headerlink" title="引起重绘的情况"></a>引起重绘的情况</h3><p>修改背景颜色、文字颜色、边框颜色、样式等</p>
<p>注：回流一定引起重绘、因此回流是一件很消耗性能的事情，所以开发中要避免回流</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="网页解析过程："><a href="#网页解析过程：" class="headerlink" title="网页解析过程："></a>网页解析过程：</h1><p><img src="/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20230322214252101.png" alt="image-20230322214252101"></p>
<p><img src="/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20230322215014488.png" alt="image-20230322215014488"></p>
<h2 id="HTML解析过程"><a href="#HTML解析过程" class="headerlink" title="HTML解析过程"></a>HTML解析过程</h2><p>默认情况下服务器给浏览器返回index.html文件，因此解析HTML是所有步骤的开始，解析HTML过程会构建Dom Tree</p>
<p><img src="/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20230322215643759.png" alt="image-20230322215643759"></p>
<h2 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h2><p>在解析过程中，如果遇到CSS的link元素，会有浏览器下载对应的CSS文件（不会影响DOM）的解析</p>
<p>对CSS下载完成后，会对CSS文件进行解析，解析出规则树，即CSSOM</p>
<p><img src="/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20230322220941332.png" alt="image-20230322220941332"></p>
<h2 id="构建Render-Tree"><a href="#构建Render-Tree" class="headerlink" title="构建Render Tree"></a>构建Render Tree</h2><p>当DOM Tree和CSSOM Tree有了过后就可以两者结合构建Render Tree了</p>
<p><img src="/2023/03/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20230322221500301.png" alt="image-20230322221500301"></p>
<p>注：link元素不会阻塞DOM Tree的构建，但会阻塞Render Tree的构建</p>
<p>​        Render Tree和Dom Tree并不是一一对应的关系，对于display为none的元素，不会出现在Render Tree中</p>
<h2 id="布局和绘制"><a href="#布局和绘制" class="headerlink" title="布局和绘制"></a>布局和绘制</h2><p>渲染树会显示每个节点的样式，但不会给出每个节点的尺寸和位置，布局就是确定渲染树中每个节点的宽度、高度和位置信息</p>
<p>绘制就是将布局阶段计算的每个frame转为屏幕上实际的像素点，包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素</p>
<h2 id="script元素和页面解析的关系"><a href="#script元素和页面解析的关系" class="headerlink" title="script元素和页面解析的关系"></a>script元素和页面解析的关系</h2><p>在HTML解析过程中，遇到script元素是不能继续构建DOM Tree的；会首先下载JavaScript代码，并执行脚本，等脚本执行结束后，继续解析HTML，构建DOM Tree</p>
<p><strong><em>原因：</em></strong> JavaScript的一个作用是操作DOM，并修改DOM，如果等DOM Tree构建完成后执行JavaScript，会引起严重的回流和重绘，影像性能</p>
<p><strong><em>但是：</em></strong> 目前的Vue/React开发模式，脚本比HTML页面更重，等到JavaScript解析会造成页面阻塞，在脚本执行完成钱，用户在界面上看不到任何东西</p>
<h3 id="script解析优化：defer、async"><a href="#script解析优化：defer、async" class="headerlink" title="script解析优化：defer、async"></a>script解析优化：defer、async</h3><p><strong><em>defer：</em></strong> 浏览器不需要等到脚本下载，继续解析HTML，构建DOM Tree  </p>
<p>​              不会阻塞DOm Tree的构建，等到DOM Tree构建完成后，在DOMContentLoaded事件之前执行代码</p>
<p>​               带多个defer的脚本按顺序执行</p>
<p>​               从某种角度来说，defer可以提高性能，并且推荐放到head元素中</p>
<p>​                注：defer仅适用于外部脚本，对于script默认内容会忽略</p>
<p><strong><em>async：</em></strong>  脚本完全独立</p>
<p>​                浏览器不会因async阻塞</p>
<p>​                async不能保证不同脚本之间的顺序，独立下载、运行</p>
<p>​                async不能保证在DOMcontentLoaded之前或之后运行</p>
<p><strong><em>defer通常用于文档解析后会操作DOM的JavaScript代码，并且对多个script文件有顺序要求的</em></strong></p>
<p><strong><em>async通常用于独立的脚本，对其他脚本，DOM没有依赖的</em></strong></p>
<h2 id="回流和重绘（见浏览器优化）"><a href="#回流和重绘（见浏览器优化）" class="headerlink" title="回流和重绘（见浏览器优化）"></a>回流和重绘（见浏览器优化）</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
  <entry>
    <title>节流与抖动</title>
    <url>/2023/03/21/%E8%8A%82%E6%B5%81%E4%B8%8E%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间</p>
<p>当事件密集触发时，函数的触发会被频繁的推迟</p>
<h3 id="防抖的应用场景："><a href="#防抖的应用场景：" class="headerlink" title="防抖的应用场景："></a>防抖的应用场景：</h3><p>输入框中频繁的输入内容，搜索或提交信息</p>
<p>平凡的点击按钮，触发某个事件</p>
<p>用户缩放浏览器的resize事件</p>
<p>如：输入macbook时，输入m联想，连续输入macbook不联想，在输入完一段时间后联想</p>
<h3 id="防抖的实现："><a href="#防抖的实现：" class="headerlink" title="防抖的实现："></a>防抖的实现：</h3><p>以input输入为例：</p>
<p>html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本实现：</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2023.3</tag>
      </tags>
  </entry>
</search>
